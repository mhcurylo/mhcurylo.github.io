<!DOCTYPE html>
<html lang="en"  class="theme--light" >

<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, viewport-fit=cover">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://lunch.support/images/apple-touch-icon-144x144.png" />
  <link rel="apple-touch-icon-precomposed" sizes="120x120" href="https://lunch.support/images/apple-touch-icon-120x120.png" />
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://lunch.support/images/apple-touch-icon-72x72.png" />
  <link rel="apple-touch-icon-precomposed" sizes="57x57" href="https://lunch.support/images/apple-touch-icon-57x57.png" />
  <link href="https://lunch.support/images/favicon.gif"  rel="icon" href="favicon.gif" type="image/gif" />
  <link rel="stylesheet" href="https://lunch.support/style.css">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" rel="stylesheet">
  <title>lunch.support â€¢ a smoll c notation</title>
  
  
  
</head>

<body>
  <div id="sidebar" >
    <div class="logo-title">
      <div class="title">
        <img src=https://lunch.support/images/gencraft.png style="width:200px;height:200px;" alt="logo" />
        <h3><a href="https://lunch.support/">lunch.support</a></h3>
        <div class="description">
          <p>Philosophy as self help for software peoples.</p>
        </div>
      </div>
    </div>
    <ul class="social-links"><li><a href="https://github.com/mhcurylo" aria-label="Go to Github profile page"><i class="fab fa-github"></i></a></li><li><a href="https://www.instagram.com/emhacee" aria-label="Go to Instagram profile page"><i class="fab fa-instagram"></i></a>
      </li><li><a href="https://linkedin.com/in/mhcurylo" aria-label="Go to Linkedin profile page"><i class="fab fa-linkedin"></i></a></li>
      
    </ul>
    <div class="footer">
      
      <span>Designed by </span><a href="https://www.caicai.me">CaiCai</a>
      <div class="by_zola"><a href="https://www.getzola.org/" target="_blank">Proudly published with Zola!</a></div>
      
    </div>
  </div>
  <div id="main">
    <div class="page-top">
      <div class="nav">
        
        
        
        
        <li><a  href="https://lunch.support/">Blog</a></li>
        <li><a  href="https://lunch.support/about/">About</a></li><li><a  href="https://lunch.support/tags">Tags</a></li><li><a 
            href="https://lunch.support/archive/">Archive</a></li></div>
      <div class="information">
        <div class="back_btn">
          <a onclick="window.history.go(-1)" ><i
              class="fas fa-chevron-left"></i></a>
        </div>
        
        
        
        <div class="avatar"><img src="https://lunch.support/images/favicon.gif"></div>
      </div>
    </div>
    <div class="autopagerize_page_element">
      <div class="content">
        
<article class="post animated fadeInDown">
  <h1><a href="https:&#x2F;&#x2F;lunch.support&#x2F;post-4&#x2F;">a smoll c notation</a></h1>
  
  <div class="post-content"><h1 id="a-smoll-c-notation">a smoll c notation</h1>
<p>Although every Software Witch is expected to know the Big O notation in case she gets into smoll talk with a hiring person, they rarely use it.
The best of us keep track of the nesting of our for loops, yet it is not the loops that threaten the sanity of our minds with their intricacies.
The for loops wreak havoc on the silicon minds of our multiprocessors instead.</p>
<p>Our blood-filled lunch-stained carbon selves live, thrive, suffer and die of domain complexity.</p>
<p>I humbly propose a smoll c notation as a way of measuring the complexity of domains.</p>
<p>It is based on two basic ideas: measuring the Cardinality of simple types by ignoring the stuff with a large capital C Cardinality by assigning a smoll c cardinality of one to it and counting the smoll c cardinality of complex Algebraic Data Types algebraically.</p>
<h2 id="the-large-c-cardinality">The Large C Cardinality</h2>
<p>Cardinality is the number of possible instances a type can take.</p>
<p>For a singleton type, as in typescript <code>type One = 'OneOfOne'</code>, it is a one. For a void type, as in <code>never</code>, it is zero. A boolean Cardinality is two, as in <code>OneOfTwo | TwoOfTwo</code>  or one bit of complexity. A sixty-four-bit <code>integer</code> has two to the power of sixty-four instances, as does a sixty-four-bit <code>float</code>. A <code>string</code> contains all the books and blog posts and fake news that have and will ever be written, which must not be true and surely bifurcates into pure nonsense, a dada of Lady Gaga.</p>
<h2 id="a-smoll-c-cardinality">a smoll c cardinality</h2>
<p>To manage this madness a witch does not tell a number from another number or a string from a string.
All <code>numbers</code> and <code>strings</code> have a cardinality of one to her, a bazillion of instances mushed under a lack of comprehension.
A witch's carbon brain works in four-bit registers, it does not handle Enum Cardinalities above sixteen. Thus she assigns the smoll c cardinality of one to them as well.</p>
<h2 id="some-types">some types</h2>
<p>To assign smoll c to a type write the number of its instances or one if it is larger than sixteen (or does not fit four bits left).
Thus a smoll c cardinality is one for basic lanugage types except a boolean and a never. Never is never, zero not null. A boolean gets a cute little two.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>// the types
</span><span>never // c of zero
</span><span>null // c of one
</span><span>undefined // c of one
</span><span>number // c of one
</span><span>string // c of one
</span><span>boolean // c of two
</span></code></pre>
<h2 id="the-enums">the enums</h2>
<p>A smoll c of an enum is the number of instances of an enum which a witch comprehends and a one for the ones which a witch does not comprehend.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>// the enums
</span><span>type Zero = never; // no instance, c of zero
</span><span>type One = &#39;OneOfOne&#39;; // one instance, c of one
</span><span>type Two = &#39;OneOfTwo&#39; | &#39;TwoOfTwo&#39;; // two instances, co of two
</span><span>type Three = &#39;OneOfThree&#39; | &#39;TwoOfThree&#39; | &#39;ThreeOfThree&#39;; // three instances, c of three
</span><span>type Four = &#39;OneOfFour&#39; | &#39;TwoOfFour&#39; | &#39;ThreeOfFour&#39; | &#39;FourOfFour&#39;; // four instances, c of four
</span><span>type CountryCode = &#39;AFG&#39; | &#39;ALB&#39; | ... // forget it! c of one
</span></code></pre>
<h2 id="the-algebra">the algebra</h2>
<p>The algebra of data types consists of addition and multiplication, a sum and a product, as all nice algebras do.</p>
<p>It also has a cherry on the top of the algebra - the power of our domain functions.</p>
<h2 id="the-sum">the sum</h2>
<p>To count the smoll c cardinality of a union we add up the smoll c of its constituents.</p>
<p>Let us look at a few types.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>// the sums
</span><span>type SumWithOne = One | Two // c of three
</span><span>type SumWithZero = Three | Zero // c of three
</span><span>type SumOfThreeAndFourAndOne = Three | Four | One // c of eight
</span></code></pre>
<p>The union type written using <code>|</code> constitutes a sum in our algebra.
The first thing to notice is that the number of instances for each of the types is the number of singleton types constituting the union.
The second thing is that adding a <code>Zero</code> does not change the number of instances - we never a never.
The third thing is that if <code>number</code> is a One and <code>null</code> is a One <code>number | null</code> makes Two.</p>
<h2 id="the-product">the product</h2>
<p>To count the smoll c cardinality of a product we multiply the smoll c of the fields of the record.</p>
<p>Let us look at a few types.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>// The products
</span><span>
</span><span>type ProductWithOne = { two: Two, one: One }// c of two
</span><span>type ProductWithZero = { two: Two, zero: Zero }// no instances, c of zer!
</span><span>type ProductOfThreeAndTwo = { three: Three, two: Two }  // c of six 
</span><span>type ProductOfFourAndThreeAndTwo= { four: Four, three: Three, two: Two }  // c of twenty-four
</span><span>type ProductOfFourAndThreeAndnumber= { four: Four, three: Three, number: number }  // c of twelve 
</span><span>type ProductOfFourAndThreeAndnumberornull= { four: Four, three: Three, number: number | null }  // c of twenty-four
</span></code></pre>
<p>The record type written in typescript using <code>{}</code> constitutes a product in our algebra.
The first thing to notice is that if we add an element with one instance to a record it does not change the number of instances - we multiply by one.
The second thing is that multiplying by a zero gives zero - we can never a record with never.
The third thing is that changing a number field to nullable doubles the c cardinality.
Check this out - an array of sixty-four <code>boolean</code>s has two to the power of sixty-four instances and you can store it in a sixty-four bit non-signed integer.</p>
<h2 id="a-trick">a trick</h2>
<p>Knowing the tricks of the trade, let's count the smoll c cardinality of a bunch of types to explain to ourselves why we enjoy parsing:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>// Example
</span><span>type NullableUndefinedPerson = { age?: number | null, name?: string | null, surname?: string | null, gender?: &#39;M&#39; | &#39;F&#39; | &#39;NB&#39; | null } // smoll c of hundred thirty five 
</span><span>type NullablePerson = { age: number | null, name: string | null, surname: string | null, gender: &#39;M&#39; | &#39;F&#39; | &#39;NB&#39; | null } // smoll c of thirty two instances
</span><span>type ParsedPerson = { age: number, name: string, surname: string, gender: &#39;M&#39; | &#39;F&#39; | &#39;NB&#39; } | null // smoll c of four 
</span></code></pre>
<p>Yep, a messy type has a smoll c of hundred and thirty-five instances, a nullable one smoll c of thirty-two and parsed one smoll c of four.
Hurray for the parsers, <code>yarn install zod</code>.</p>
<h2 id="the-power-of-a-function">the power of a function</h2>
<p>To count the smoll c cardinality of a function we calculate the power of the smoll c of its output as the base and the smoll c of its input as the exponent.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>// Expotents
</span><span>type OneToThePowerOfTwo: (two: Two) =&gt; One //smoll c of one! - one possible implementation.
</span><span>type OneToThePowerOfThree: (three: Three) =&gt; One // smoll c of one! - one possible implementation.
</span><span>type ThreeToThePowerOfOne: (one: One) =&gt; Two // smoll c of two (two constant functions)
</span><span>type ThreeToThePowerOfOne: (one: One) =&gt; Three // smoll c of three (three constant functions)
</span><span>type ZeroToThePowerOfThree: (three: Three) =&gt; never // smoll c of zero! - zero possible implementations.
</span><span>type TwoToThePowerOfTwo: (two: Two) =&gt; Two // smoll c of four 
</span><span>type TwoAndTwoToThePowerOfTwo: ({two: Two, two2: Two}) =&gt; Two // smoll c of sixteen
</span><span>type TwoAndTwoToThePowerOfTwo: ({two: Two, two2: Two}) =&gt; Two | null // smoll c of eighty one
</span><span>type NullableTwoAndNullableTwoToThePowerOfTwo: ({two: Two | null, two2: Two | null}) =&gt; Two // smoll c of five hundred twelve
</span><span>type NullableTwoAndNullableTwoToThePowerOfTwo: ({two: Two | null, two2: Two | null}) =&gt; Two | null // smoll c of nineteen thousand six hundred eighty three
</span></code></pre>
<p>A function written either using the <code>function</code> keyword or a cute fat <code>=&gt;</code> is the exponent of our algebra and makes a mess pretty fast.
Functional programming techniques like abstracting away optionality allow your domain functions to stay at c of sixteen even if due to noise they are operating in uncomprehensible complexity (smoll c of 1k or larger?),
but this article is not a lecture on functional programming (or is it?).</p>
<h2 id="closures">closures</h2>
<p>When counting smoll c of a function, do include all the possible inputs and outputs, including immutable variables as input and mutable as output and input! It is revealing.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>// Closures
</span><span>let c: boolean = true;
</span><span>
</span><span>const f: (a: boolean) =&gt; boolean = // implementation 
</span></code></pre>
<p>The smoll c should be not four but <code>(a: boolean, c: boolean) =&gt; [boolean, boolean]</code> two hundred fifty-six.
This is yet another reason not to inline your functions. Let the compilers do it.</p>
<h2 id="smoll-c-and-code-branching">smoll c and code branching</h2>
<p>On a basic level, the smoll c of your function input reflects the number of branches aka pattern matches your function covers.</p>
<h2 id="our-domains">our domains</h2>
<p>Software witches die by their domains, their database schemas and their domain functions.
Whenever you wonder if <code>{ streamingURL?: string, streamingTYPE?: 'A' | 'B', streamingTOKEN?: string}</code> is better than <code>{ streaming?: { url: string, type: 'A' | 'B', token: string}</code> remember that the smoll c is like twelve to three and shift left.
All domain complexity should always be shifted left up to the entry point of the program and then ruthlessly parsed of existence.</p>
<h2 id="some-fun-edge-cases">some fun edge cases</h2>
<p>The proposed approximation of domain complexity has some funky edge cases which make sense.</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>// Some edge cases
</span><span>type lessNumbers = (a: number, b : number) =&gt; number // smoll c of one
</span><span>type moreNumbers = (a: number, b: number, c: number, d: number) =&gt; number // smoll c of one
</span><span>type aNumber = (a: number) =&gt; number // smoll c of one
</span><span>type lessBools = (a: boolean, b: boolean) =&gt;  boolean // smoll c of sixteen
</span><span>type lessBools = (a: boolean, b: boolean, c: boolean) =&gt;  boolean // smoll c of two hundred fifty-six
</span><span>type aNumberAndTwoBooleans = (a: number, b: boolean, c: boolean) =&gt;  boolean // smoll c of sixteen
</span><span>type aNumberAndTwoBooleans = (a: number | null, b: boolean, c: boolean) =&gt;  boolean // smoll c of two hundred fifty six
</span></code></pre>
<p>The assumption here is that some of the code does something with numbers - we do not know what and it is not interesting to a witch. It should never change, thus - let it go - smoll c of one.
Once you put a number and two enums we can expect that the code will choose what to do with a number. This is a scary thought.
Once you put a nullable number and two enums we can expect that the code will choose what to do with a number it can choose to create out of nothing in different ways. This is a very, very scary thought indeed.</p>
<h2 id="thanks">thanks!</h2>
<p>Thanks for going through the humble smoll c notation proposal I hope it will make you wonder whether that null in your product type would not look better as a non-nullable field in a freshly spun discriminated union. Enjoi your brew, witch!</p>
</div>
  <div class="post-footer">
    <div class="meta">
      <div class="info">
        
        <i class="far fa-sun"></i><span class="date">2024-08-21</span>
        
        
        <i class="fas fa-tags"></i>
        
        <a class="tag" href="https://lunch.support/tags/development">&nbsp;development</a>
        
        <a class="tag" href="https://lunch.support/tags/software">&nbsp;software</a>
        
        <a class="tag" href="https://lunch.support/tags/design">&nbsp;design</a>
        
        
      </div>
    </div>
  </div>
</article>







<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['$$', '$$'], ["\\[", "\\]"]],
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>




      </div>
    </div>
  </div>
  
  
  <script>
    function showLanguages() {
      let currentDisplay = document.getElementById("languages").style.display;
      if (currentDisplay == 'none') {
        document.getElementById("languages").style.display = 'block';
      } else {
        document.getElementById("languages").style.display = 'none';
      }
    }
  </script>
</body>

</html>
