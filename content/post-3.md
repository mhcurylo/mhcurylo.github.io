+++
title = "Knowing software: objects of knowledge."
template = "page.html"
date = 2024-03-19
[taxonomies]
tags = ["philosophy", "development", "software", "design", "epistemololgy"]
[extra]
summary = "Witches! Listen to the broad-shouldered philospher."
mathjax = "tex-mml"
+++


> What is the solemn declaration?
> -- <cite>Protarchus</cite>

> That fixed and pure and true and what we call unalloyed knowledge has to do with the things which are eternally the same without change or mixture, or with that which is most akin to them; and all other things are to be regarded as secondary and inferior.
> -- <cite>Socrates</cite>

Contrary to popular belief Plato did not propose a consistent theory of ideas. Instead, he wished to wish a world of eternal ideas into being through a counterfactual reasoning. The premise, reformulated for software peoples to comprehend the madness of its ratio, goes somehow like this:

Given an object of knowledge, when it changes, then it invalidates all knowledge about it. Thus an object of knowledge, to be known, has to be pure and eternal and unchanging and always true. 
Here comes the counterfactual: If gods did not use `const's` to create a world of unchanging ideas then all philosopher's attempts at pure true eternal knowledge are doomed. Therefore the world of unalloyed knowledge must exist, or else philosophers have nothing to know here. Ka-boom.

Neither the scientific practices of naturalist philosophers which came before Plato nor the much more intricate proofs of contemporary Sophists stood a chance against the backwards projecting cone of survivor bias. Plato's reasoning divorced the idea of knowledge from the toll of practice and married it to a wager on the existence of the ethereal for centuries to come.

Since after the erasure of the contemporaries of Plato, philosophers, to know, must believe in the existence of eternal objects of knowledge.

Yet, software peoples are no philosophers. They do not perceive by the light of the reason but by the palms of their hands. Software people are witches, weaving the instances of Canvas2D with the mechanical switches of Linux terminals. A philosopher said that the point is not to interpret, but to change the world. Software witches do neither interpret nor change the existing world. They blend, mix and link the sources of closed and open source libraries into brand new beings, daemons interpreting and acting upon the mortal worlds.

Software witch does not wager on gods, as she creates her own objects of knowledge. Thus, contrary to a philosopher, she has no need to have gods before her. It does not mean, fellow witches, that we have nothing to learn from the sages of yore. Quite the contrary. Even if Plato's counterfactual is an immature wish, the solemn declaration still holds. Fixed and pure and true we call unalloyed knowledge has to do with the things which are eternally the same without change or mixture. It takes a lot less effort to understand that, what does not change. `Const` is easier to deal with than `var`. A witch does not have to place a bet on the gods creating such a knowable world. The whims of gods do not affect her.

Whatever we can know our software is up to us, the software peoples. We create our own objects of knowledge. The incomprehensible shantytowns we tend to dwell in are of our own making. Often, the creations we lurk in resemble the legendary [Big Balls of Mud](http://laputan.org/mud/), as warm and cosy as unfathomable. The dynamic languages some of us love and weave between, around and all over can output anything but objects of unalloyed knowledge. Oh, code! Ever changing, ever accumulating, branched out, merged in, rebased, pulled and pushed. Code we link, code we import, code we depend on and code we will never comprehend. 

We know our way around big balls of mud and we know how to transform them with the sleight of our hands. First, we split the big balls of mud into small, cute balls of fluff, as those are easier to hold to. Then we sprinkle on what makes code a bit purer and truer and unalloyed - types. To make the types purer and truer we learn from the concrete, persisted data. Finally, to make the concrete data purer and truer and unalloyed we store the data schemas, containing the entropic flows of light into validated brews with tags, descriptions and numbers assigned to them. To purify the transformations of data into unchanging, knowable abstractions we utilise state machines and specification languages. To make the changes in data schemas knowable we version them.

Plato was known among fellow wrestlers as broad-shouldered. As witches, we know that broad-shouldered people tend to be listened to by the virtue of their shoulders alone and thus tend to ignore them. We know that it is the shoulders which make them more likely to get through the backwards projecting cone of survivor bias. Even so, the broad-shouldered one can teach us something very basic about knowing the software we inhabit.  We can never know the everchanging code. What we can comprehend is purer, truer and unalloyed - the data types and the function signatures, the data schemas and the state machines. Those are what sensible objects of knowledge are spun of.
